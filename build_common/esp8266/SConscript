#******************************************************************
#
# Copyright 2016 Web of Objects project All Rights Reserved.
# Author: Khaled Q. AbdelFadeel <kqorany2@gmail.com> and Khaled F. Elsayed <kelsayed@gmail.com>
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

##
# This script includes esp8266 specific config
##
import os
import platform

Import('env')

def __parse_config(f):
	dict = {}
        print f
	if not os.path.isfile(f):
		return dict

	file = open(f, 'r')
	strs = file.readlines()
	for str in strs:
		str = str.strip()
		if len(str) > 0 and str[0] == '#':
			continue

		idx = str.find('=')
		if idx > 0:
			dict.setdefault(str[0:idx], str[idx + 1:])

	return dict

def __get_boards(dict):
	boards = []
	keys = dict.keys()
	for key in keys:
		idx = key.find('.name')
		if idx > 0:
			if key.endswith('.name'):
				boards.append(key[0:idx])
	return boards

def __get_cpu(dict, board):
	cpus = []
	keys = dict.keys()
	for key in keys:
		idx = key.find(board + '.menu.cpu.')
		start = len(board + '.menu.cpu.')
		if idx >= 0:
			end = key.find('.', start)
			if end > 0:
				cpu = key[start:end]
				exist = False
				for c in cpus:
					if c == cpu:
						exist = True
						break

				if not exist:
					cpus.append(cpu)
	return cpus

def __get_board_info(board, key):
	if cpu:
		v = boards_info.get(board + '.menu.cpu.' + cpu + key)
		if not v:
			v = boards_info.get(board + key)
	else:
		v = boards_info.get(board + key)
	return v

def __search_files(path, pattern, ondisk=True, source=True, strings=False, recursive=True):
	if not recursive:
		return Glob(pattern, ondisk, source, strings)

	matches = []
	for root, dirnames, filenames in os.walk(path):
		# This is a helper function to build Esp8266 libraries. Scripts are using this function
		# to add all the files in a folder as compilation targets rather than specifying each
		# file to compile from a Esp8266 library folder.

		# Since the function is recursive, it adds even "/library/<library-name>/examples" to the
		# compilation list. This is an extra overhead as stack is never going to use ".o" generated
		# for these examples.
		if 'examples' not in root:
			matches.extend(Glob(os.path.join(root, pattern), ondisk, source, strings))
	return matches

# To make sure the src is built in 'BUILD_DIR' (by default it will be built at
# the same directory as the .c .cpp .S)
def __src_to_obj(env, srcs):
	objs = []
	prefix = str(env.get('BOARD')) + '_'
	if env.get('CPU'):
		prefix += str(env.get('CPU')) + '_'

	build_dir = os.path.join(env.get('BUILD_DIR'), 'esp8266')
	for src in srcs:
		if (os.path.isabs(src.path)):
			obj = src.path.replace(esp8266_home, build_dir)
		else:
			obj = os.path.join(build_dir, src.path)
		i = obj.rfind('.')
		obj = obj[0:i]
		if env.get('OBJSUFFIX'):
			obj += env.get('OBJSUFFIX')
		objs.extend(env.Object(obj, src, OBJPREFIX=prefix))
	return objs

def __import_lib(env, lib):
	lib_path = os.path.join(esp8266_home, 'libraries', lib)
	if not os.path.exists(lib_path):
		lib_path = os.path.join(esp8266_home, 'hardware', 'esp8266com', 'esp8266', 'libraries', lib)
	if os.path.exists(os.path.join(lib_path, 'src')):
		lib_path = os.path.join(lib_path, 'src')

	env.AppendUnique(CPPPATH = [lib_path])

	if os.path.exists(os.path.join(lib_path, 'utility')):
		env.AppendUnique(CPPPATH = [os.path.join(lib_path, 'utility')])

	if os.path.exists(os.path.join(lib_path, 'include')):
		env.AppendUnique(CPPPATH = [os.path.join(lib_path, 'include')])

	lib_src = []
	lib_src.extend(__search_files(lib_path, '*.S'))
	lib_src.extend(__search_files(lib_path, '*.c'))
	lib_src.extend(__search_files(lib_path, '*.cpp'))

	lib_obj = __src_to_obj(env, lib_src)
	build_dir = env.get('BUILD_DIR')
	if build_dir:
		lib_a = env.StaticLibrary(build_dir + lib, lib_obj)
	else:
		lib_a = env.StaticLibrary(lib, lib_obj)

	# If we link libSPI.a, the final binary is not getting launched
	# on the board.  Which is not the case if we directly use SPI.o.

	#if lib == 'SPI':
	#	for obj in lib_obj:
	#		if obj.name.endswith('SPI.o'):
	#			env.PrependUnique(LIBS = [File(obj)])
	#else:
	#	env.AppendUnique(LIBS = [File(lib_a[0])])
	env.AppendUnique(LIBS = [File(lib_a[0])])

def __build_core(env):
	core_src = __search_files(core_folder, '*.S')
	core_src.extend(__search_files(core_folder, '*.c'))
	core_src.extend(__search_files(core_folder, '*.cpp'))

	core_src.extend(__search_files(variant_folder, '*.S'))
	core_src.extend(__search_files(variant_folder, '*.c'))
	core_src.extend(__search_files(variant_folder, '*.cpp'))

	core_obj = __src_to_obj(env, core_src)

	prefix = env.get('BOARD') + '_'
	if env.get('CPU'):
		prefix += env.get('CPU') + '_'

	core = os.path.join(env.get('BUILD_DIR', '.'), 'esp8266', prefix + 'core')
	s_core = env.StaticLibrary(core, core_obj)

	env.AppendUnique(LIBS = [File(s_core[0])])

	# To avoid compiler issue. Otherewise there may be warnings:
	# 	undefined reference to '_exit' '_close', '_getpid' ...
	# Above functions are used in libc.a and implemented in syscalls_sam3.c
	#if env.get('TARGET_ARCH') == 'esp8266':
	#	for obj in core_obj:
	#		if obj.name.endswith('syscalls_sam3.o'):
	#			env.AppendUnique(LIBS = [File(obj)])


def __create_bin(env, source):
	name = source
	if env.get('TARGET_ARCH') == 'esp8266':
		create_bin = esp8266_home + '/hardware/esp8266com/esp8266/tools/esptool/esptool -eo ' + esp8266_home + '/hardware/esp8266com/esp8266/bootloaders/eboot/eboot.elf -bo '+name+'.bin -bm '+ flash_mode +' -bf '+ flash_speed +' -bz ' + flash_size +' -bs .text -bp 4096 -ec -eo '+name+' -bs .irom0.text -bs .text -bs .data -bs .rodata -bc -ec'
                bin = env.Command(name+'.bin', source, create_bin)

def __upload(env, binary):
	print 'uploading bin file'
        if target_arch == 'esp8266':
		port = '/dev/ttyUSB0'
		speed = '115200'
		verb = '-vv'
		upload_cmd = esp8266_home + '/hardware/esp8266com/esp8266/tools/esptool/esptool '+verb+' -cd ck -cb '+speed+' -cp '+port+' -ca 0x00000 -cf '+binary
	        print "Upload command: %s" %upload_cmd
		upload = env.Command('upload', binary, upload_cmd)
                env.Default('upload')


# Print the command line that to upload binary to the board
def __upload_help(env):
	if target_arch == 'esp8266':
		protocol = __get_board_info(board, '.upload.protocol')
		speed = __get_board_info(board, '.upload.speed')
		


# ESP8266_HOME build option
help_vars = Variables()
help_vars.Add(PathVariable('ESP8266_HOME', 'ESP8266 root directory', os.environ.get('ESP8266_HOME')))
help_vars.Update(env)
Help(help_vars.GenerateHelpText(env))

target_arch = env.get('TARGET_ARCH')

# Verify that the esp8266, time, red bear, and nordic libraries are
# installed.  If not, get them and install them.
#SConscript(os.path.join(env.get('SRC_DIR'), 'extlibs', 'esp8266', 'SConscript'))
esp8266_home = env.get('ESP8266_HOME')
print 'ESP8266_HOME = ' + str(env.get('ESP8266_HOME'))

# Overwrite suffixes and prefixes
if env['HOST_OS'] == 'win32':
	env['OBJSUFFIX'] = '.o'
	env['SHOBJSUFFIX'] = '.os'
	env['LIBPREFIX'] = 'lib'
	env['LIBSUFFIX'] = '.a'
	env['SHLIBPREFIX'] = 'lib'
	env['SHLIBSUFFIX'] = '.so'
	env['LIBPREFIXES'] = ['lib']
	env['LIBSUFFIXES'] = ['.a', '.so']
	env['PROGSUFFIX'] = ''
elif platform.system().lower() == 'darwin':
	env['SHLIBSUFFIX'] = '.so'
	env['LIBSUFFIXES'] = ['.a', '.so']
	env['PROGSUFFIX'] = ''

# Debug/release relative flags
if env.get('RELEASE'):
	env.AppendUnique(CCFLAGS = ['-Os'])
	env.AppendUnique(CPPDEFINES = ['__ets__','ICACHE_FLASH','LWIP_OPEN_SRC','NDEBUG'])
else:
	env.AppendUnique(CPPDEFINES = ['__ets__','ICACHE_FLASH','LWIP_OPEN_SRC'])
	env.AppendUnique(CCFLAGS = ['-g'])

# Force header presence defines
env.AppendUnique(CPPDEFINES = ['HAVE_ESP8266_TIME_H'])

# BOARD / CPU option


version = '10608'
boards_info = __parse_config(os.path.join(esp8266_home, 'hardware', 'esp8266com', 'esp8266', 'boards.txt'))
platform_info = __parse_config(os.path.join(esp8266_home, 'hardware', 'esp8266com', 'esp8266', 'platform.txt'))
env.PrependENVPath('PATH', os.path.join(esp8266_home, 'hardware', 'esp8266com', 'esp8266', 'tools', 'xtensa-lx106-elf', 'bin'))
env.Replace(CC = 'xtensa-lx106-elf-gcc')
env.Replace(CXX = 'xtensa-lx106-elf-g++')
env.Replace(AR = 'xtensa-lx106-elf-ar')
env.Replace(AS = 'xtensa-lx106-elf-as')
env.Replace(LINK = 'xtensa-lx106-elf-gcc')
env.Replace(RANLIB = 'xtensa-lx106-elf-ranlib')

#Board option, let user to select the board
boards = __get_boards(boards_info)
print boards
help_vars = Variables()
help_vars.Add(EnumVariable('BOARD', 'esp8266 board', boards[3], boards)) 
# generic

help_vars.Update(env)
Help(help_vars.GenerateHelpText(env))

#CPU option
board = env.get('BOARD')
cpus = __get_cpu(boards_info, board)

if len(cpus) > 0:
	help_vars = Variables()
	help_vars.Add(EnumVariable('CPU', 'esp8266 board cpu', cpus[0], cpus))
	help_vars.Update(env)
	Help(help_vars.GenerateHelpText(env))


# ESP8266 commom flags
cpu = env.get('CPU')
mcu = __get_board_info(board, '.build.mcu')
f_cpu = __get_board_info(board, '.build.f_cpu')
usb_vid = __get_board_info(board, '.build.vid')
usb_pid = __get_board_info(board, '.build.pid')
variant = __get_board_info(board, '.build.variant')

if not usb_vid:
	usb_vid = __get_board_info(board, '.vid.0')
if not usb_pid:
	usb_pid = __get_board_info(board, '.pid.0')

core_base = os.path.join(esp8266_home, 'hardware','esp8266com', 'esp8266')
sdk_folder = os.path.join(esp8266_home, 'hardware', 'esp8266com', 'esp8266','tools','sdk')
sdk_include_folder = os.path.join(sdk_folder,'include')
lwip_include_folder = os.path.join(sdk_folder,'lwip','include')
env.AppendUnique(CPPPATH = [sdk_include_folder])
env.AppendUnique(CPPPATH = [lwip_include_folder])
sdk_lib_folder = os.path.join(sdk_folder,'lib')
libc_lib_folder = os.path.join(sdk_folder,'libc','xtensa-lx106-elf','lib')
env.AppendUnique(LIBPATH = [sdk_lib_folder])
env.AppendUnique(LIBPATH = [libc_lib_folder])
env.AppendUnique(LIBS = ['m','gcc','hal','phy','net80211','lwip_gcc','wpa','main','pp','smartconfig','wps','crypto','axtls','mesh','stdc++','c','espnow','wpa2'])

variant_folder = os.path.join(core_base, 'variants', variant)
env.AppendUnique(CPPPATH = [variant_folder])

flash_layout = 'eagle.flash.512k64.ld'
flash_mode = 'dio'
flash_speed = '40'
flash_size = '512K'

core = __get_board_info(board, '.build.core')
core_folder = os.path.join(core_base, 'cores', core)
env.AppendUnique(CPPPATH = [core_folder])

comm_flags = ['-U__STRICT_ANSI__','-MMD','-ffunction-sections','-fdata-sections']
if f_cpu:
	env.AppendUnique(CPPDEFINES =['-DF_CPU=' + f_cpu])

env.AppendUnique(CPPDEFINES =['-DARDUINO=' + version])
env.AppendUnique(ASFLAGS = ['-x', 'assembler-with-cpp','-MMD'])
env.AppendUnique(CFLAGS = ['-Wpointer-arith','-Wno-implicit-function-declaration','-Wl,-EL','-fno-inline-functions','-nostdlib','-mlongcalls','-mtext-section-literals','-falign-functions=4','-std=gnu99'])
env.AppendUnique(CFLAGS = comm_flags)
env.AppendUnique(CXXFLAGS = ['-mlongcalls','-mtext-section-literals','-fno-exceptions','-fno-rtti','-falign-functions=4','-std=c++11'])
env.AppendUnique(CXXFLAGS = comm_flags)
env.AppendUnique(LINKFLAGS = ['-g','-w','-Os','-nostdlib','-Wl,--no-check-sections','-u call_user_start','-u _printf_float','-u _scanf_float','-Wl,-static','-L'+sdk_folder+'/ld','-T'+flash_layout,'-Wl,--gc-sections','-Wl,-wrap,system_restart_local','-Wl,-wrap,register_chipv6_phy','-Wl,--start-group'])

# Make sure the .d files are removed when clean the build
if env.GetOption('clean'):
	dfs = __search_files(env.get('BUILD_DIR'), '*.d')
	for df in dfs:
		Execute(Delete(df))

env.AppendUnique(CPPDEFINES =['-DARDUINO_BOARD="ESP8266_ESP01"'])
__build_core(env)
env['CPPDEFINES'].remove(('-DARDUINO_BOARD="ESP8266_ESP01"',))

env.AddMethod(__import_lib, "ImportLib") #import esp8266 library
env.AddMethod(__build_core, "BuildCore") #build esp8266 core
env.AddMethod(__create_bin, "CreateBin") #create binary files(.bin)
env.AddMethod(__upload, "Upload") #Upload binary to board
env.AddMethod(__upload_help, "UploadHelp") #print the command line that to upload binary to the board
